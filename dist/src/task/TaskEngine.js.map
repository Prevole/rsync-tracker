{"version":3,"file":"TaskEngine.js","sourceRoot":"","sources":["../../../src/task/TaskEngine.ts"],"names":[],"mappings":";;;;;;;;;;;AAEA,2DAAmC;AAEnC,2DAAmC;AAInC;IAOE,YAAY,MAAqB,EAAE,OAAoB;QACrD,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACzB,CAAC;IAED,OAAO;QACL,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,MAAe,EAAE,OAA6B,EAAE,EAAE;YAC5F,OAAO,MAAM,CAAC,MAAM,CAAC,IAAI,eAAK,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QAC1E,CAAC,EAAE,EAAE,CAAC,CAAC;QAEP,MAAM,CAAC,OAAO,CAAC,CAAC,KAAY,EAAE,EAAE;YAC9B,IAAI,cAAc,GAAG,IAAI,CAAC;YAE1B,OAAO,CAAC,KAAK,CAAC,OAAO,EAAE,EAAE;gBACvB,MAAM,IAAI,GAAa,KAAK,CAAC,OAAO,EAAE,CAAC;gBAEvC,IAAI,cAAc,IAAI,CAAC,CAAC,cAAc,IAAI,IAAI,CAAC,0BAA0B,EAAE,CAAC,EAAE;oBAC5E,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;oBACrC,cAAc,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;oBAC5B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,oBAAoB,cAAc,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,SAAS,EAAE,CAAC,CAAC;iBACnF;qBAAM;oBACL,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,wCAAwC,CAAC,CAAC;iBAC5D;aACF;QACH,CAAC,CAAC,CAAC;IACL,CAAC;CACF;AA5BC;IADC,gBAAM,EAAE;0CACe;AAL1B,6BAiCC","sourcesContent":["import Configuration from '../config/Configuration';\nimport TrackerConfiguration from '../config/TrackerConfiguration';\nimport Inject from '../ioc/Inject';\nimport Logger from '../logging/Logger';\nimport Queue from '../queue/Queue';\nimport Taskable from './Taskable';\nimport TaskBuilder from './TaskBuilder';\n\nexport default class TaskEngine {\n  private readonly config: Configuration;\n  private readonly builder: TaskBuilder;\n\n  @Inject()\n  private logger!: Logger;\n\n  constructor(config: Configuration, builder: TaskBuilder) {\n    this.config = config;\n    this.builder = builder;\n  }\n\n  process() {\n    const queues = this.config.trackers.reduce((queues: Queue[], tracker: TrackerConfiguration) => {\n      return queues.concat(new Queue().queueAll(this.builder.build(tracker)));\n    }, []);\n\n    queues.forEach((queue: Queue) => {\n      let previousResult = true;\n\n      while (!queue.isEmpty()) {\n        const task: Taskable = queue.dequeue();\n\n        if (previousResult || (!previousResult && task.canRunIfPreviousTaskFailed())) {\n          this.logger.info('Task will be run');\n          previousResult = task.run();\n          this.logger.info(`Task ran and was ${previousResult ? 'successful' : 'failure'}`);\n        } else {\n          this.logger.info('Task is skipped (previous task failed)');\n        }\n      }\n    });\n  }\n}\n"]}